var MEM_SIZE = 512, MAX_ADDRESS = MEM_SIZE - 1, BIT_MASK_16 = 65535, BIT_MASK_SIGN = 32768, DECIMAL_LENGTH = 10, HEX_LENGTH = 16, MAX_POSITIVE = BIT_MASK_16 >> 1, MIN_NEGATIVE = BIT_MASK_SIGN, MAX_HEX_ADDRESS_LENGTH = MAX_ADDRESS.toString(HEX_LENGTH).length, MAX_ADDRESS_LENGTH = MAX_ADDRESS.toString().length, MAX_16_BIT_HEX_DIGITS = 4, MAX_16_BIT_DEC_DIGITS = 5, PC_TRACKING_COLOR = "pink", SP_TRACKING_COLOR = "lightgreen", HALF_TABLE_LENGTH = 186, COMMENT = ";", LABEL_INDICATOR = ".", INS_TYPE_MEM_ACCESS = "memory_access", INS_TYPE_LOGICAL = "logical", INS_TYPE_ARITHMETIC =
    "arithmetic", INS_TYPE_BRANCHING = "branching", BASE_VERSION = 10, CLOCK_PERIOD = 0, IGNORE_BREAKPOINTS = !1, LINE2MEM = {}, MEM2LINE = {}, LABELS2LINES = {}, LABELS2MEM = {}, RUNNING = !1, PROGRAM_INTERVAL_ID, ERROR_INCORRECT_ARGS = "ERROR: Based off of the number of commas which are used to delimit arguments, you have too many arguments.", ERROR_INCORRECT_SPACING = "ERROR: The number of tokens differs from your first instruction and your first argument.", ERROR_INCORRECT_INS = "ERROR: The instruction does not exist.", ERROR_INCORRECT_NUM_ARGS =
    "ERROR: The number of arguments does not match the instruction.", ERROR_INCORRECT_ARG_TYPE = "ERROR: The argument provided is incorrect.", ERROR_INSUFFICIENT_MEMORY = "ERROR: Memory size is too small for the entered program.", ERROR_ADDRESS_OUT_OF_BOUNDS = "ERROR: the address you are trying to input is out of bounds", ERROR_STACK_OVERFLOW = "ERROR: The PC is now greater than the SP. Stack overflow has occurred.", ERROR_VALUES_AFTER_LABEL = "ERROR: There are tokens following address labelling.", ERROR_LABEL_VALUE_OVERFLOW =
    "ERROR: The given address for the label doesn't fit within the memory constraints.", ERROR_SAME_LABEL_MULTIPLE_LINES = "ERROR: This label has already been used.", LIST_REG_NAMES = {
    R0: !0,
    R1: !0,
    R2: !0,
    R3: !0
}, NUM_REGS = Object.keys(LIST_REG_NAMES).length, CHECK_ARGS = {I: checkI, R: checkR, M: checkM}, ZCNO_MAPPINGS = {
    Z: 0,
    C: 1,
    N: 2,
    O: 3
}, INSTRUCTIONS = {
    SET: {
        N_ARGS: 2,
        ARG0: "IMR",
        ARG1: "R",
        f: do_set,
        OP_CODES: [1, 2, 3],
        INS_TYPE: INS_TYPE_MEM_ACCESS,
        ZCNO: "----",
        INS_PC: "+3",
        INS_SP: "+0",
        INS_DESCRIPTION: "Sets register specified by arg1 to the value in arg0. If arg0 is a memory value it takes the value at arg0 and places it into the register in arg1."
    },
    MOV: {
        N_ARGS: 2,
        ARG0: "IMR",
        ARG1: "MR",
        f: do_mov,
        OP_CODES: [4, 5, 6, 7, 8, 9],
        INS_TYPE: INS_TYPE_MEM_ACCESS,
        ZCNO: "----",
        INS_PC: "+3",
        INS_SP: "+0",
        INS_DESCRIPTION: "Sets memory location specified by arg1 to the value in arg0. If arg0 is a memory value it takes the value at arg0 and places it into the register in arg1."
    },
    POP: {
        N_ARGS: 1,
        ARG0: "R",
        ARG1: "-",
        f: do_pop,
        OP_CODES: [10],
        INS_TYPE: INS_TYPE_MEM_ACCESS,
        ZCNO: "----",
        INS_PC: "+2",
        INS_SP: "+1",
        INS_DESCRIPTION: "Pops the value located at SP - 1 off the stack and places this value into register specified in arg0. Note that this operation doesn't clear the stack value hence the old stack value is still present. This is how deleting on a computer generally occurs; a pointer is deleted or changed to another location."
    },
    PSH: {
        N_ARGS: 1,
        ARG0: "R",
        ARG1: "-",
        f: do_psh,
        OP_CODES: [11],
        INS_TYPE: INS_TYPE_MEM_ACCESS,
        ZCNO: "----",
        INS_PC: "+2",
        INS_SP: "-1",
        INS_DESCRIPTION: "Pushes value specified in arg0 into memory location of SP."
    },
    CCL: {
        N_ARGS: 0,
        ARG0: "-",
        ARG1: "-",
        f: do_ccl,
        OP_CODES: [12],
        INS_TYPE: INS_TYPE_MEM_ACCESS,
        ZCNO: "0000",
        INS_PC: "+1",
        INS_SP: "+0",
        INS_DESCRIPTION: "Zeros out all conditions in the condition register."
    },
    RSH: {
        N_ARGS: 1,
        ARG0: "R",
        ARG1: "-",
        f: do_rsh,
        OP_CODES: [13],
        INS_TYPE: INS_TYPE_LOGICAL,
        ZCNO: "?---",
        INS_PC: "+2",
        INS_SP: "+0",
        INS_DESCRIPTION: "Performs " + "logical right shift".link("https://en.wikipedia.org/wiki/Logical_shift") + " on the register specified in arg0. If result is 0 sets 0 flag."
    },
    LSH: {
        N_ARGS: 1,
        ARG0: "R",
        ARG1: "-",
        f: do_lsh,
        OP_CODES: [14],
        INS_TYPE: INS_TYPE_LOGICAL,
        ZCNO: "-?-?",
        INS_PC: "+2",
        INS_SP: "+0",
        INS_DESCRIPTION: "Performs " + "logical left shift".link("https://en.wikipedia.org/wiki/Logical_shift") + " on the register specified in arg0. If the most significant bit in arg0 is asserted then the C and O bit get asserted."
    },
    AND: {
        N_ARGS: 2,
        ARG0: "R",
        ARG1: "R",
        f: do_and,
        OP_CODES: [15],
        INS_TYPE: INS_TYPE_LOGICAL,
        ZCNO: "?0?0",
        INS_PC: "+2",
        INS_SP: "+0",
        INS_DESCRIPTION: "Performs a logical " + "and".link("https://en.wikipedia.org/wiki/Logical_conjunction") + " between arg0 and arg1 and places the result into arg1. The Z bit is set if the result is 0, the N bit is set if the resulting most significant bit is 1, and the C and O bit are always set to 0."
    },
    OR: {
        N_ARGS: 2,
        ARG0: "R",
        ARG1: "R",
        f: do_or,
        OP_CODES: [16],
        INS_TYPE: INS_TYPE_LOGICAL,
        ZCNO: "?0?0",
        INS_PC: "+3",
        INS_SP: "+0",
        INS_DESCRIPTION: "Performs a logical " + "or".link("https://en.wikipedia.org/wiki/Logical_disjunction") + " between arg0 and arg1 and places the result into arg1. The Z bit is set if the result is 0, the N bit is set if the resulting most significant bit is 1, and the C and O bit are always set to 0."
    },
    ADD: {
        N_ARGS: 2,
        ARG0: "R",
        ARG1: "R",
        f: do_add,
        OP_CODES: [17],
        INS_TYPE: INS_TYPE_ARITHMETIC,
        ZCNO: "????",
        INS_PC: "+3",
        INS_SP: "+0",
        INS_DESCRIPTION: "Performs " + "2's complement addition".link("https://en.wikipedia.org/wiki/Two's_complement#Addition") +
        " between arg0 and arg1 and places the result into arg1. The Z bit is set if the result is 0, the N bit is set if the resulting most significant bit is 1, and the C and O bit are set when the result should be greater than 0x7FFF or if the negative result should be less than 0x8000."
    },
    SUB: {
        N_ARGS: 2,
        ARG0: "R",
        ARG1: "R",
        f: do_sub,
        OP_CODES: [18],
        INS_TYPE: INS_TYPE_ARITHMETIC,
        ZCNO: "????",
        INS_PC: "+3",
        INS_SP: "+0",
        INS_DESCRIPTION: "Performs " + "2's complement subtraction".link("https://en.wikipedia.org/wiki/Two's_complement#Subtraction") +
        " between arg0 and arg1 and places the result into arg1. The Z bit is set if the result is 0, the N bit is set if the resulting most significant bit is 1, and the C and O bit are set when the result should be greater than 0x7FFF or if the negative result should be less than 0x8000."
    },
    MUL: {
        N_ARGS: 2,
        ARG0: "R",
        ARG1: "R",
        f: do_mul,
        OP_CODES: [19],
        INS_TYPE: INS_TYPE_ARITHMETIC,
        ZCNO: "?-?-",
        INS_PC: "+3",
        INS_SP: "+0",
        INS_DESCRIPTION: "Performs " + "2's complement multiplication".link("https://en.wikipedia.org/wiki/Two's_complement#Multiplication") +
        " between arg0 and arg1 and places the result into arg1. The Z bit is set if the result is 0, the N bit is set if the resulting most significant bit is 1, and the C and O bit are set when the result should be greater than 0x7FFF or if the negative result should be less than 0x8000."
    },
    DIV: {
        N_ARGS: 2,
        ARG0: "R",
        ARG1: "R",
        f: do_div,
        OP_CODES: [20],
        INS_TYPE: INS_TYPE_ARITHMETIC,
        ZCNO: "?-?-",
        INS_PC: "+3",
        INS_SP: "+0",
        INS_DESCRIPTION: "Performs signed division between arg0 and arg1 and places result in arg1. If arg1 is 0, the result is 0. The result will be returned in 2's complement form."
    },
    CMP: {
        N_ARGS: 2,
        ARG0: "IMR",
        ARG1: "IMR",
        f: do_cmp,
        OP_CODES: [21, 22, 23, 24, 25, 26, 27, 28, 29],
        INS_TYPE: INS_TYPE_BRANCHING,
        ZCNO: "????",
        INS_PC: "+3",
        INS_SP: "+0",
        INS_DESCRIPTION: "Performs that same operation as subtract except it doesn't fill arg1 with the result. The purpose of this instruction is to fill the condition flags."
    },
    BRN: {
        N_ARGS: 1,
        ARG0: "M",
        ARG1: "-",
        f: do_brn,
        OP_CODES: [30],
        INS_TYPE: INS_TYPE_BRANCHING,
        ZCNO: "----",
        INS_PC: "arg0",
        INS_SP: "+0",
        INS_DESCRIPTION: "Branches to address in arg0 if N flag is set."
    },
    BRA: {
        N_ARGS: 1,
        ARG0: "M",
        ARG1: "-",
        f: do_bra,
        OP_CODES: [31],
        INS_TYPE: INS_TYPE_BRANCHING,
        ZCNO: "----",
        INS_PC: "arg0",
        INS_SP: "+0",
        INS_DESCRIPTION: "Branch unconditionally to address in arg0."
    },
    BRZ: {
        N_ARGS: 1,
        ARG0: "M",
        ARG1: "-",
        f: do_brz,
        OP_CODES: [32],
        INS_TYPE: INS_TYPE_BRANCHING,
        ZCNO: "----",
        INS_PC: "arg0",
        INS_SP: "+0",
        INS_DESCRIPTION: "Branches to address in arg0 if Z flag is set."
    },
    BRG: {
        N_ARGS: 1,
        ARG0: "M",
        ARG1: "-",
        f: do_brg,
        OP_CODES: [33],
        INS_TYPE: INS_TYPE_BRANCHING,
        ZCNO: "----",
        INS_PC: "arg0",
        INS_SP: "+0",
        INS_DESCRIPTION: "Branches if greater than or if both Z and N flag aren't set."
    },
    JSR: {
        N_ARGS: 1,
        ARG0: "M",
        ARG1: "-",
        f: do_jsr,
        OP_CODES: [34],
        INS_TYPE: INS_TYPE_BRANCHING,
        ZCNO: "----",
        INS_PC: "arg0",
        INS_SP: "-1",
        INS_DESCRIPTION: "Pushes the next instruction address onto the stack and jumps to address in arg0."
    },
    RTN: {
        N_ARGS: 0,
        ARG0: "-",
        ARG1: "-",
        f: do_rtn,
        OP_CODES: [35],
        INS_TYPE: INS_TYPE_BRANCHING,
        ZCNO: "----",
        INS_PC: "?",
        INS_SP: "+1",
        INS_DESCRIPTION: "Jumps to the address at the top entry of the stack."
    },
    STP: {
        N_ARGS: 0,
        ARG0: "-",
        ARG1: "-",
        f: do_stp,
        OP_CODES: [36],
        INS_TYPE: INS_TYPE_BRANCHING,
        ZCNO: "----",
        INS_PC: "+0",
        INS_SP: "+0",
        INS_DESCRIPTION: "Halts the program execution. Call this when the program has completed running."
    }
};
function generate_byte_code_mapping() {
    var a = [0], b;
    for (b in INSTRUCTIONS)if (INSTRUCTIONS.hasOwnProperty(b))for (var c = INSTRUCTIONS[b], d = c.ARG0, e = 0, f = d.length; e < f; e++)for (var g = c.ARG1, l = g.length, h = 0; h < l; h++)a.push([b, d[e] + g[h]]);
    return a
}
var BYTE_TO_INS = generate_byte_code_mapping();
function do_set(a, b) {
    var c = get_arg_val(a);
    setR(b[1], c);
    setPC(getPC() + 3)
}
function do_mov(a, b) {
    var c = get_arg_val(a), d = b;
    checkR(b) && (d = get_arg_val(b));
    write_memory(d, c);
    write_op_code(d);
    setPC(getPC() + 3)
}
function do_add(a, b) {
    var c = get_arg_val(a), d = get_arg_val(b), e = c + d;
    arithmetic_flag_setting(c, d, e);
    setR(b[1], e & BIT_MASK_16)
}
function do_sub(a, b) {
    var c = get_arg_val(a), d = twos_invert_sign(get_arg_val(b)), e = c + d;
    arithmetic_flag_setting(c, d, e);
    setR(b[1], e & BIT_MASK_16)
}
function do_mul(a, b) {
    var c = get_arg_val(a), d = get_arg_val(b), e = c * d;
    arithmetic_flag_setting(c, d, e);
    setR(b[1], e & BIT_MASK_16)
}
function zero_and_negative_flag_setting(a) {
    0 == (a & BIT_MASK_16) ? setCCF("Z", 1) : setCCF("Z", 0);
    a & BIT_MASK_16 & BIT_MASK_SIGN ? setCCF("N", 1) : setCCF("N", 0)
}
function overflow_and_carry_flag_setting(a, b, c) {
    check_overflow(a, b, c) ? (setCCF("O", 1), setCCF("C", 1)) : (setCCF("O", 0), setCCF("C", 0))
}
function arithmetic_flag_setting(a, b, c) {
    overflow_and_carry_flag_setting(a, b, c);
    zero_and_negative_flag_setting(c);
    setPC(getPC() + 3)
}
function do_div(a, b) {
    var c = convert_to_js_integer(get_arg_val(a)), d = convert_to_js_integer(get_arg_val(b));
    0 === d ? setR(b[1], 0) : (c = Math.floor(c / d), 0 > c && (c = twos_invert_sign(Math.abs(c))), zero_and_negative_flag_setting(c), setR(b[1], c & BIT_MASK_16));
    setPC(getPC() + 3)
}
function do_rsh(a) {
    var b = get_arg_val(a) >> 1;
    setR(a[1], b);
    setCCF("Z", 0 < (b & BIT_MASK_SIGN) & 1);
    setPC(getPC() + 2)
}
function do_lsh(a){var b=get_arg_val(a)<<1;setR(a[1],b);setCCF("O",0<(b&BIT_MASK_SIGN)&1);setCCF("C",0<(b&BIT_MASK_SIGN)&1);setPC(getPC()+2)}function do_and(a,b){var c=get_arg_val(a),d=get_arg_val(b),c=c&d;setCCF("O",0);setCCF("C",0);zero_and_negative_flag_setting(c);setR(b[1],c&BIT_MASK_16);setPC(getPC()+3)}function do_or(a,b){var c=get_arg_val(a),d=get_arg_val(b),c=c|d;setCCF("O",0);setCCF("C",0);zero_and_negative_flag_setting(c);setR(b[1],c&BIT_MASK_16);setPC(getPC()+3)}
function do_cmp(a,b){var c=get_arg_val(a),d=twos_invert_sign(get_arg_val(b));arithmetic_flag_setting(c,d,c+d)}function do_brn(a){1==getCCF("N")?setPC(a):setPC(getPC()+2)}function do_bra(a){setPC(a)}function do_brz(a){1==getCCF("Z")?setPC(a):setPC(getPC()+2)}function do_brg(a){1!==getCCF("N")&&1!==getCCF("Z")?setPC(a):setPC(getPC()+2)}function do_jsr(a){var b=getSP(),c=getPC();write_memory(b,c+2);write_op_code(b);setSP(b-1);setPC(a)}
function do_rtn(){var a=getSP();a>=MAX_ADDRESS?write_error_to_console("ERROR: The sp is already at top of stack."):(setPC(get_memory(a+1)),setSP(a+1))}function do_pop(a){var b=getSP();b>=MAX_ADDRESS?write_error_to_console("ERROR: The sp is already at top of stack."):(setR(a[1],get_memory(b+1)),setPC(getPC()+2),setSP(b+1))}function do_psh(a){var b=getSP(),c=getPC();write_memory(b,getR(a[1]));write_op_code(b);setSP(b-1);setPC(c+2)}
function do_ccl(){setCCF("O",0);setCCF("C",0);setCCF("Z",0);setCCF("N",0);setPC(getPC()+1)}function do_stp(){}function format_addr(a){a&=MAX_ADDRESS;a=convert_to_proper_string_base(a);return BASE_VERSION==HEX_LENGTH?"0x"+Array(MAX_HEX_ADDRESS_LENGTH-a.length+1).join("0")+a.toUpperCase():Array(MAX_ADDRESS_LENGTH-a.length+1).join("0")+a}
function format_numbers(a){a&=BIT_MASK_16;a=convert_to_proper_string_base(a);return BASE_VERSION==HEX_LENGTH?"0x"+Array(MAX_16_BIT_HEX_DIGITS-a.length+1).join("0")+a.toUpperCase():Array(MAX_16_BIT_DEC_DIGITS-a.length+1).join("0")+a}function convert_to_proper_string_base(a){return BASE_VERSION===DECIMAL_LENGTH?a.toString():a.toString(HEX_LENGTH)}
function strip_label_definition(a) {
    if (a[0] == LABEL_INDICATOR) {
        a = a.split(/\s+/g);
        var b = a.length;
        return 1 < b ? check_number(a[1]) ? 2 < b ? a.slice(2).join(" ") : "" : a.slice(1).join(" ") : ""
    }
    return a
}
function strip_whitespace_and_comment(a) {
    if ("" == a || /^\s+$/.test(a))return "";
    a = a.split(COMMENT)[0].trim();
    return "" == a || /^\s+$/.test(a) ? "" : a
}
function set_op_code_type(a, b) {
    switch (b) {
        case "I":
            return "$" + a;
        case "R":
            return "R" + a;
        default:
            return a
    }
}
function get_arg_val(a) {
    if ("$" == a[0])return parseInt(a.substr(1, a.length));
    if ("R" == a[0])return getR(a[1]);
    a = get_memory(a);
    return parseInt(a.substring(1, a.length))
}
function format_number_check_type(a) {
    return checkM(a) || check_number(a) ? format_numbers(a) : checkI(a) ? "$" + format_numbers(a.substring(1)) : a
}
function write_memory(a, b) {
    a = parseInt(a);
    check_memory_limits(a) ? $("#addr" + a).html(format_number_check_type(b)) : write_error_to_console(ERROR_ADDRESS_OUT_OF_BOUNDS)
}
function index_op_codes(a, b) {
    return a.indexOf(b)
}
function return_arg_type(a) {
    return checkR(a) ? "R" : checkI(a) ? "I" : checkM(a) ? "M" : "L"
}
function write_op_code(a) {
    a = parseInt(a);
    var b = $("#opCode" + a), c = get_memory(a);
    if (checkI(c))b.html(format_numbers(c.substring(1))); else if (checkR(c))b.html(format_numbers(c[1])); else if (check_number(c))b.html(format_numbers(c)); else {
        var d = INSTRUCTIONS[c], c = d.OP_CODES;
        if (2 > c.length)b.html(format_numbers(c[0])); else {
            var e = d.N_ARGS, f = get_memory(a + 1), f = return_arg_type(f), f = index_op_codes(d.ARG0, f);
            1 === e ? b.html(format_numbers(c[f])) : (e = d.ARG0.length, a = get_memory(a + 2), a = return_arg_type(a), a = index_op_codes(d.ARG1,
                a), d = d.ARG1.length, 1 === e ? b.html(format_numbers(c[a])) : 1 === d ? b.html(format_numbers(c[f])) : b.html(format_numbers(c[f * e + a])))
        }
    }
}
function get_op_code(a) {
    a = parseInt(a);
    return check_memory_limits(a) ? parseInt($("#opCode" + a).html()) : (write_error_to_console(ERROR_ADDRESS_OUT_OF_BOUNDS), stop_program_running(), -1)
}
function get_memory(a) {
    a = parseInt(a);
    return check_memory_limits(a) ? $("#addr" + a).html() : (write_error_to_console(ERROR_ADDRESS_OUT_OF_BOUNDS), stop_program_running(), -1)
}
function getR(a) {
    return parseInt($("#R" + a + "content").html())
}
function setR(a, b) {
    $("#R" + a + "content").html(format_numbers(b))
}
function getPC() {
    return parseInt($("#PCcontent").html())
}
function setPC_no_jump(a) {
    uncolor_pc();
    check_memory_limits(a) ? getPC() > getSP() ? (write_error_to_console(ERROR_STACK_OVERFLOW), stop_program_running()) : ($("#PCcontent").html(format_numbers(a)), color_pc()) : (write_error_to_console(ERROR_ADDRESS_OUT_OF_BOUNDS), stop_program_running())
}
function setPC(a) {
    setPC_no_jump(a);
    jump2pc_in_mm()
}
function getSP() {
    return parseInt($("#SPcontent").html())
}
function setSP(a) {
    uncolor_sp();
    check_memory_limits(a) ? getPC() > getSP() ? write_error_to_console(ERROR_STACK_OVERFLOW) : ($("#SPcontent").html(format_numbers(a)), color_sp()) : write_error_to_console(ERROR_ADDRESS_OUT_OF_BOUNDS)
}
function getCCF(a) {
    return $("#CCcontent").html()[ZCNO_MAPPINGS[a]]
}
function setCCF(a, b) {
    var c = $("#CCcontent"), d = c.html(), d = d.substring(0, ZCNO_MAPPINGS[a]) + b + d.substring(ZCNO_MAPPINGS[a] + 1, HEX_LENGTH);
    c.html(d)
}
function check_and_assign_label2mem(a, b, c, d) {
    a in LABELS2MEM || a in LABELS2LINES ? b.push("Line " + c + " " + ERROR_SAME_LABEL_MULTIPLE_LINES) : LABELS2MEM[a] = parseInt(d)
}
function check_and_assign_label2lines(a, b, c) {
    a in LABELS2MEM || a in LABELS2LINES ? b.push("Line " + c + " " + ERROR_SAME_LABEL_MULTIPLE_LINES) : LABELS2LINES[a] = c
}
function is_negative(a) {
    return 0 < (a & BIT_MASK_SIGN)
}
function is_positive(a) {
    return !is_negative(a) && 0 != a
}
function is_2s_positive(a) {
    return 0 < a && a <= MAX_POSITIVE
}
function is_2s_negative(a) {
    return a >= BIT_MASK_SIGN && a <= BIT_MASK_16
}
function convert_to_js_integer(a) {
    return is_positive(a) ? a : -twos_invert_sign(a)
}
function twos_invert_sign(a) {
    return ~a + 1 & BIT_MASK_16
}
function check_overflow(a, b, c) {
    return is_positive(a) && is_positive(b) || is_negative(a) && is_negative(b) ? !is_2s_positive(c) : 0 == a || 0 == b ? !1 : !is_2s_negative(c)
}
function checkR(a) {
    return a.toUpperCase() in LIST_REG_NAMES
}
function checkI(a) {
    return /(^\$0x[0-9a-f]+$)|(^\$[0-9]+$)/i.test(a) ? (a = parseInt(a.substring(1)), 0 <= a && a <= BIT_MASK_16) : !1
}
function check_memory_limits(a) {
    a = parseInt(a);
    return 0 <= a && a <= MAX_ADDRESS
}
function check_number(a) {
    return /(^0x[0-9a-f]+$)|(^[0-9]+$)/i.test(a)
}
function checkM(a) {
    return check_number(a) ? (a = parseInt(a), check_memory_limits(a)) : a in LABELS2LINES || a in LABELS2MEM
}
function check_individual_args(a, b, c) {
    for (var d = 0; d < a.length; d++)if (CHECK_ARGS[a[d]](b))return c;
    return {state: !1, error: ERROR_INCORRECT_ARG_TYPE}
}
function check_instruction(a, b, c, d) {
    var e = {state: !0, error: ""};
    if (!(a in INSTRUCTIONS))return e.state = !1, e.error = ERROR_INCORRECT_INS, e;
    if (INSTRUCTIONS[a].N_ARGS != d)return e.state = !1, e.error = ERROR_INCORRECT_NUM_ARGS, e;
    if (2 == d) {
        d = INSTRUCTIONS[a].ARG0;
        a = INSTRUCTIONS[a].ARG1;
        e = check_individual_args(d, b, e);
        if (!e.state)return e;
        e = check_individual_args(a, c, e)
    } else 1 == d && (d = INSTRUCTIONS[a].ARG0, e = check_individual_args(d, b, e));
    return e
}
function init_mm(){for(var a=$("#main_memory"),b=0;b<MEM_SIZE;b++){var c=$("<tr></tr>"),d=$("<td></td>").attr("id","address"+b).html(format_addr(b)),e=$("<td></td>").attr("id","addr"+b).html(format_numbers(0)),f=$("<td></td>").attr("id","opCode"+b).html(format_numbers(0)),g=$("<td></td>").attr("id","label"+b);a.append(c.append(d).append(e).append(f).append(g))}}
function get_labels(a, b) {
    for (var c = 1, d = 0; d < a.length; d++) {
        var e = strip_whitespace_and_comment(a[d]);
        if ("" != e && e[0] == LABEL_INDICATOR) {
            var f = e.split(/\s+/g), e = f[0];
            if (1 < f.length) {
                var g = f[1];
                if (check_number(g)) {
                    if (2 < f.length) {
                        b.push("Line " + c + " " + ERROR_VALUES_AFTER_LABEL);
                        c++;
                        continue
                    } else if (!check_memory_limits(g)) {
                        b.push("Line " + c + " " + ERROR_LABEL_VALUE_OVERFLOW);
                        c++;
                        continue
                    }
                    check_and_assign_label2mem(e, b, c, g)
                } else check_and_assign_label2lines(e, b, c)
            } else for (f = d + 1; f < a.length; f++)if ("" != a[f] && !/^\s+$/.test(a[f]) &&
                (g = $.trim(a[f].split(COMMENT)[0]), "" != g && !/^\s+$/.test(g) && g[0] != LABEL_INDICATOR)) {
                check_and_assign_label2lines(e, b, f + 1);
                break
            }
        }
        c++
    }
}
function assemble(){clear_console();clear_memory_image();write_to_console("Assembling has begun...");var a=editor.getValue().split("\n"),b=[],c=[],d={};LABELS2MEM={};LABELS2LINES={};get_labels(a,b);for(var e=1,f=0;f<a.length;f++){var g=strip_label_definition(strip_whitespace_and_comment(a[f]));if(""!=g){var l=g.split(","),g="",h;if(2==l.length){h=l[0].split(/\s+/g);var k="",l=l[1].trim();2==h.length?(g=h[0],k=h[1],h=check_instruction(g,k,l,2),h.state?(d[e]=c.length,c.push(g),c.push(k),c.push(l)):
(b.push("Line "+e+" "+h.error),c=[])):(b.push("Line "+e+" "+ERROR_INCORRECT_SPACING),c=[])}else 1==l.length?(k=l[0].split(/\s+/g),1==k.length?(g=k[0],h=check_instruction(g,"","",0),h.state?(d[e]=c.length,c.push(g)):(b.push("Line "+e+" "+h.error),c=[])):2==k.length?(g=k[0],k=k[1],h=check_instruction(g,k,"",1),h.state?(d[e]=c.length,c.push(g),c.push(k)):(b.push("Line "+e+" "+h.error),c=[])):(b.push("Line "+e+" "+ERROR_INCORRECT_SPACING),c=[])):(b.push("Line "+e+" "+ERROR_INCORRECT_ARGS),c=[])}e++}c.length>
MEM_SIZE&&(c=[],b.push("Line "+e+" "+ERROR_INSUFFICIENT_MEMORY));if(b.length){write_to_console("Assembled unsuccessfully. Errors:");for(var f=0;f<b.length;f++)write_error_to_console(b[f]);return!1}a=c.length;for(f=0;f<a;f++)b=c[f],"."===b[0]&&(b=b in LABELS2MEM?LABELS2MEM[b]:d[LABELS2LINES[b]]),write_memory(f,b);for(f=0;f<a;f++)write_op_code(f);LINE2MEM=jQuery.extend(!0,{},d);MEM2LINE=_.invert(d);for(var m in LABELS2LINES)if(LABELS2LINES.hasOwnProperty(m)){c=LINE2MEM[LABELS2LINES[m]];if(!check_memory_limits(c)){write_error_to_console(ERROR_ADDRESS_OUT_OF_BOUNDS);
return}$("#label"+c).html(m.slice(1))}for(m in LABELS2MEM)LABELS2MEM.hasOwnProperty(m)&&$("#label"+LABELS2MEM[m]).html(m.slice(1));write_to_console("Assembled successfully. Data now stored in main memory.");return!0}
function step() {
    var a = getPC(), b = get_memory(a), c;
    if (b in INSTRUCTIONS && "STP" !== b)c = INSTRUCTIONS[b].N_ARGS, 0 == c ? INSTRUCTIONS[b].f() : 1 == c ? (c = get_memory(a + 1), INSTRUCTIONS[b].f(c)) : 2 == c && (c = get_memory(a + 1), a = get_memory(a + 2), INSTRUCTIONS[b].f(c, a)), a = getPC(), write_to_console("End step at address " + a); else if (c = parseInt(b), !isNaN(c) && BYTE_TO_INS.length > c && 0 < c) {
        var b = BYTE_TO_INS[c][0], d = BYTE_TO_INS[c][1];
        c = d[0];
        "-" === c ? INSTRUCTIONS[b].f() : (c = set_op_code_type(get_op_code(a + 1), c), d = d[1], "-" === d ? INSTRUCTIONS[b].f(c) :
            (a = set_op_code_type(get_op_code(a + 2), d), INSTRUCTIONS[b].f(c, a)));
        a = getPC();
        write_to_console("End step at address " + a)
    } else write_to_console("Stepped to end of program.")
}
function run_program_noBP() {
    write_to_console("Program started running...");
    IGNORE_BREAKPOINTS = !0;
    resume_program_running()
}
function load_and_run() {
    assemble() && run_program()
}
function load_and_run_noBP() {
    assemble() && run_program_noBP()
}
function run_program() {
    write_to_console("Program started running...");
    resume_program_running()
}
function execute_program() {
    PROGRAM_INTERVAL_ID = setInterval(function () {
        var a = getPC(), b = get_memory(a);
        if (b in INSTRUCTIONS && "STP" !== b) {
            var c = INSTRUCTIONS[b].N_ARGS;
            if (0 == c)INSTRUCTIONS[b].f(), a += 1; else if (1 == c)c = get_memory(a + 1), INSTRUCTIONS[b].f(c), a += 2; else if (2 == c) {
                var c = get_memory(a + 1), d = get_memory(a + 2);
                INSTRUCTIONS[b].f(c, d);
                a += 3
            }
            !IGNORE_BREAKPOINTS && pcAtBP(MEM2LINE, a) && (write_to_console("Breakpoint hit, main memory address: " + a), stop_program_running())
        } else write_to_console("Finished running program."),
stop_program_running()},CLOCK_PERIOD)}function stop_program_running(){RUNNING&&(enable_buttons_when_run(),clearInterval(PROGRAM_INTERVAL_ID),IGNORE_BREAKPOINTS=RUNNING=!1)}function resume_program_running(){disable_buttons_when_run();RUNNING=!0;execute_program()}
function clear_memory_image(){stop_program_running();var a;for(a=0;a<MEM_SIZE;a++)write_memory(a,"0000"),$("#label"+a).html(""),write_op_code(a);setCCF("O",0);setCCF("C",0);setCCF("Z",0);setCCF("N",0);for(a=0;a<NUM_REGS;a++)setR(a,0);setPC(0);setSP(MAX_ADDRESS);clear_console()}
function disable_buttons_when_run(){$("#load_button").prop("disabled",!0);$("#step_button").prop("disabled",!0);$("#assemble_button").prop("disabled",!0);$("#run_button").prop("disabled",!0);$("#run_ignore_bp_button").prop("disabled",!0);$("#pause_button").prop("disabled",!1)}
function enable_buttons_when_run(){$("#run_button").prop("disabled",!1);$("#step_button").prop("disabled",!1);$("#assemble_button").prop("disabled",!1);$("#run_ignore_bp_button").prop("disabled",!1);$("#pause_button").prop("disabled",!0)}function write_to_console(a){var b=$("#console");b.append($("<p></p>").html(a)).scrollTop(b.prop("scrollHeight"))}function write_error_to_console(a){var b=$("#console");b.append($("<p></p>").html(a).css("color","red")).scrollTop(b.prop("scrollHeight"))}
function jump2pc_in_mm(){var a=$("#address"+getPC()).parent().position();$("#div_main_memory").scrollTop(Math.max(0,a.top-HALF_TABLE_LENGTH))}function jump2sp_in_mm(){var a=$("#address"+getSP()).parent().position();$("#div_main_memory").scrollTop(Math.max(0,a.top-HALF_TABLE_LENGTH))}function change_clock_rate(){var a=parseInt($("#program_speed").val());CLOCK_PERIOD=isNaN(a)||0===a?0:1E3/a;stop_program_running();RUNNING&&resume_program_running()}
function change_base(){BASE_VERSION="decimal_input"==$("#base_value").val()?DECIMAL_LENGTH:HEX_LENGTH;var a;for(a=0;a<MEM_SIZE;a++){$("#address"+a).html(format_addr(a));var b=$("#opCode"+a),c=b.html();b.html(format_numbers(c));write_memory(a,$("#addr"+a).html())}for(a=0;a<NUM_REGS;a++)setR(a,getR(a));setPC_no_jump(getPC());setSP(getSP())}function save_file(){var a=editor.getValue(),a=new Blob([a],{type:"text/plain;charset=utf-8"});saveAs(a,"assembly_program.asm")}
function load_file(){var a=$("#load_button");a.on("change",function(b){b=a[0].files[0];var c=new FileReader;c.onload=function(a){editor.setValue(c.result)};c.readAsText(b)})}function color_pc(){$("#addr"+getPC()).parent().css({backgroundColor:PC_TRACKING_COLOR})}function uncolor_pc(){$("#addr"+getPC()).parent().removeAttr("style")}function color_sp(){$("#addr"+getSP()).parent().css({backgroundColor:SP_TRACKING_COLOR})}function uncolor_sp(){$("#addr"+getSP()).parent().removeAttr("style")}
function remove_line2mem_mem2line(){LINE2MEM={};MEM2LINE={}}function init(){init_mm();remove_line2mem_mem2line();color_pc();color_sp()}function clear_console(){$("#console").html("")}$("#init_memory_button").on("click",clear_memory_image);$("#assemble_button").on("click",assemble);$("#run_button").on("click",run_program);$("#save_button").on("click",save_file);$("#load_button").on("click",load_file);$("#clear_console_button").on("click",clear_console);$("#step_button").on("click",step);
$("#pause_button").on("click",stop_program_running);$("td[rowspan]").addClass("hasRowSpan");
