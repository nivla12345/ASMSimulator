Hardware Architecture
16 bit ISA
4 registers, R0, R1, R2, R3
1 SP - stack pointer
1 PC - program counter
1 CC: Zero flag (Z), Carry flag (C), Negative flag (N), Overflow flag (O)
1 kb worth of memory

Arguments: 
1) Immediate (I) - constant values (hex delimited by a 0x), delimited by: $
   ie. $0x1234 or $4660
2) Registers (R) - R0, R1, R2, and R3
3) Memory locations (M) - number must be: [0:1023]. To dereference place inside
   square brackets. You can only perform at most 1 dereference.
   ie. 0x0010 or 16
   ie. [16]

Comments start at ;

Instructions
SET 2
MOV 2
ADD 2
SUB 2
MUL 2
DIV 2
RSH 1
LSH 1
AND 2
OR  2
CMP 2
BRN 1
BRA 1
BRZ 1
BRG 1
BRL 1
JSR 1
RTN 0
POP 1
PSH 1
CCL 0

Legend:
Instruction Arg0, Arg1
Arg0 restrictions | Arg1 restrictions
Description
Example(s)

Data handling and memory operations:
SET A, B 
A = IRM | B = R
Sets register B to whatever A is.
Example 1) SET R1 R2    puts R1 into R2
Example 2) SET $0x15 R2 puts constant 0x15 into R2

Let 0x0100 be stored in address 10
Let 0x5555 be stored in address 0x0100
Example 3) SET 10 R2    puts 0x0100 into R2
Example 4) SET [10] R2  puts 0x5555 into R2

MOV A, B
A = IRM | B = M
Moves whatever A is to B.
R1 = 0xFDEC
Example 1) MOV R1, 0x5   Puts 0xFDEC into address 5
Let 0x10 be stored into 0x5
Example 2) MOV R1, [0x5] Puts 0xFDEC into address 0x10

Arithmetic and logic operations
All arguments must be R. The letters are semi colon indicate the condition
flag that gets influenced.

ADD A, B   Adds A and B and stores into B; ZCNO
SUB A, B   Subtracts A and B and stores into B; ZCNO
MUL A, B   Multiplies A and B and stores into B; ZN
DIV A, B   Divides A and B and stores into B; ZN (Watch out for errors div by 0)
LSH A	   Arithmetic left shift and stores into A; ZCNO
RSH A	   Arithmetic right shift and stores into A; ZCNO
AND A, B   Logically ands A and B and stores into B; Z
OR  A, B   Logically ors A and B and stores into B; Z


CMP A, B   Subtracts A from B without storing; ZCNO

Control Flow:
A must be a valid memory location
BRN A      Branch to A if negative
BRA A      Branch to A always
BRZ A      Branch to A if zero
BRG A      Branch to A if greater than
BRL A      Branch to A if less than
JSR A      Jumps to function and pushes all registers to stack, 
		   updates SP accordingly
RTN        Returns and pops everything back into registers
		   updates SP accordingly

Stack operations:
PSH A      Pushes whatever is in A into A
POP	A      Pops top of stack into A and decrements SP

Other:
CCL        Clears condition registers (sets all to 0)




Sample Text:
; Enter your program text here!

; Including test instructions below:


SET $0xFFFF, R0; Setting register 0 to be 0xFFFF
SET R0, R1     ; Setting register 0 to be register 1
SET R1, R2
SET R3, R2

RSH R2
CCL