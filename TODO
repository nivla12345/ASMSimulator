TODO:
- Map instructions to machine code values.
- Write up ISA description with examples.
- Add a features page
- Add alerts telling the user if they switch tabs they will lose all changes they've made, only 
  prompt once. Or just open in new tab
- minify my stuff using google minify
- Enable inputting negative numbers
  o I might wanna mask instead of reject numbers > 16 bits.
  o I also probably wanna compare the negative limits when checking immediate.
  o I'll need to go through the various assembly operations to see if negative values are
    implemented properly.
  o The option to display signed vs unsigned can be added to the Decimal section
- Change main memory values to hex on hex change.

Future Ideas
- Enable search inside of the main memory box (probably in the title bar) and jump to the
  appropriate address (search with both label name and address).
- Allow labelling of specific memory locations. This will also mean expanding labels to other
  instructions that reference addresses. Will have to check that nothing gets overriden here.
- Square bracket to dereference (this will need to be done in run time)
- Link main memory location to line number in code to highlight section
  of code hit in text editor (only do this if change to bytemode)
  If I do this, the functionality will be: press debug to keep debugging if paused.
- Enable hardware customization
- Enable choosing textarea editor
- Before running, re-program memory if not at breakpoint. This allows for 
  back to back runs. The problem here is that after stepping, a run would reprogram the whole
  program.
- Make everything object oriented in order to break up ISA.js into multiple files
- Add unit tests

DONE:
- Make sure you can't set breakpoints on comments + blanklines
- Clear console
- Run and step
- Format registers to look pretty 
  (what's left here is to get the table to not change size randomly)
  (might also want to change a few magic strings)
- Have hex and decimal mode
- Enable labels inside of assembly (labels can only be used for branching + subroutine ops)
- Format main memory to look pretty
- Format console to look pretty, have auto-scroll
- Look into panels to encapsulate objects
- When breakpoint newline, update the breakpoint cookie
- Go through TODOs in code
- Scroll with pc
- Save and load
- Add label column to main memory
- Use the bootstrap glyphs
- Implement saving in JSR and RTN
- Add stack pointer highlighting, given my implementation the SP and PC should never collide
- Have different CPU speeds
- Use the twitter bootstrap button feature to blank out the button while 
  running
- Pause program button
- Add click on PC to jump to PC and click on SP to jump to SP
- Set up debug button with a drop down to reveal ignore breakpoints
- Give code specific color + auto complete
- Allow running values in hex when stored in memory.

